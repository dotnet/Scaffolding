// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.DotNet.Scaffolding.Core.Scaffolders;
using Microsoft.DotNet.Scaffolding.Helpers.Roslyn;
using Microsoft.DotNet.Scaffolding.Helpers.Services;
using Microsoft.DotNet.Scaffolding.Helpers.Steps;
using Microsoft.DotNet.Tools.Scaffold.Aspire.Helpers;
using Microsoft.Extensions.Logging;

namespace Microsoft.DotNet.Tools.Scaffold.Aspire.Commands;

internal class StorageCommand : ICommandWithSettings
{
    private readonly ILogger _logger;
    private readonly IFileSystem _fileSystem;
    //Dictionary to hold autogenerated project paths that are created during build-time for Aspire host projects.
    //The string key is the full project path (.csproj) and the string value is the full project name (with namespace
    private Dictionary<string, string> _autoGeneratedProjectNames;
    public StorageCommand(IFileSystem fileSystem, ILogger logger)
    {
        _fileSystem = fileSystem;
        _logger = logger;
        _autoGeneratedProjectNames = [];
    }

    public async Task<int> ExecuteAsync(CommandSettings settings, ScaffolderContext context)
    {
        if (!ValidateStorageCommandSettings(settings))
        {
            return -1;
        }
        _logger.LogInformation("Installing packages...");
        await InstallPackagesAsync(settings);

        _logger.LogInformation("Updating App host project...");
        var appHostResult = await UpdateAppHostAsync(settings);

        _logger.LogInformation("Updating web/worker project...");
        var workerResult = await UpdateWebApiAsync(settings);

        if (appHostResult && workerResult)
        {
            _logger.LogInformation("Finished");
            return 0;
        }
        else
        {
            _logger.LogInformation("An error occurred.");
            return -1;
        }
    }

    internal async Task<bool> UpdateAppHostAsync(CommandSettings commandSettings)
    {
        CodeModifierConfig? config = ProjectModifierHelper.GetCodeModifierConfig("storage-apphost.json", System.Reflection.Assembly.GetExecutingAssembly());
        if (config is null)
        {
            _logger.LogInformation("Unable to parse 'storage-apphost.json' CodeModifierConfig.");
            return false;
        }

        var workspaceSettings = new WorkspaceSettings
        {
            InputPath = commandSettings.AppHostProject
        };

        var hostAppSettings = new AppSettings();
        hostAppSettings.AddSettings("workspace", workspaceSettings);
        var codeService = new CodeService(hostAppSettings, _logger);
        var codeModifierProperties = await GetAppHostPropertiesAsync(commandSettings, codeService);
        CodeChangeStep codeChangeStep = new()
        {
            CodeModifierConfig = config,
            CodeModifierProperties = codeModifierProperties,
            CodeService = codeService,
            Logger = _logger,
            ProjectPath = commandSettings.AppHostProject,
            CodeChangeOptions = new CodeChangeOptions()
        };

        return await codeChangeStep.ExecuteAsync();
    }

    private async Task<IDictionary<string, string>> GetAppHostPropertiesAsync(CommandSettings commandSettings, CodeService codeService)
    {
        var codeModifierProperties = new Dictionary<string, string>();
        var autoGenProjectNames = await AspireHelpers.GetAutoGeneratedProjectNamesAsync(commandSettings.AppHostProject, codeService);
        //add the web worker project name
        if (autoGenProjectNames.TryGetValue(commandSettings.Project, out var autoGenProjectName))
        {
            codeModifierProperties.Add("$(AutoGenProjectName)", autoGenProjectName);
        }

        if (StorageConstants.StoragePropertiesDict.TryGetValue(commandSettings.Type, out var storageProperties) && storageProperties is not null)
        {
            codeModifierProperties.Add("$(StorageVariableName)", storageProperties.VariableName);
            codeModifierProperties.Add("$(AddStorageMethodName)", storageProperties.AddClientMethodName);
        }

        return codeModifierProperties;
    }

    internal async Task<bool> UpdateWebApiAsync(CommandSettings commandSettings)
    {
        CodeModifierConfig? config = ProjectModifierHelper.GetCodeModifierConfig("storage-webapi.json", System.Reflection.Assembly.GetExecutingAssembly());
        if (config is null)
        {
            return false;
        }

        var codeModifierProperties = GetApiProjectProperties(commandSettings);
        CodeChangeStep codeChangeStep = new()
        {
            CodeModifierConfig = config,
            CodeModifierProperties = codeModifierProperties,
            Logger = _logger,
            ProjectPath = commandSettings.Project,
            CodeChangeOptions = new CodeChangeOptions()
        };

        return await codeChangeStep.ExecuteAsync();
    }

    private IDictionary<string, string> GetApiProjectProperties(CommandSettings commandSettings)
    {
        var codeModifierProperties = new Dictionary<string, string>();
        if (StorageConstants.StoragePropertiesDict.TryGetValue(commandSettings.Type, out var storageProperties) &&
            storageProperties is not null)
        {
            codeModifierProperties.Add("$(AddClientMethodName)", storageProperties.AddClientMethodName);
            codeModifierProperties.Add("$(StorageVariableName)", storageProperties.VariableName);
        }

        return codeModifierProperties;
    }

    internal bool ValidateStorageCommandSettings(CommandSettings commandSettings)
    {
        if (string.IsNullOrEmpty(commandSettings.Type) || !GetCmdsHelper.StorageTypeCustomValues.Contains(commandSettings.Type, StringComparer.OrdinalIgnoreCase))
        {
            string storageTypeDisplayList = string.Join(", ", GetCmdsHelper.StorageTypeCustomValues.GetRange(0, GetCmdsHelper.StorageTypeCustomValues.Count - 1)) +
                (GetCmdsHelper.StorageTypeCustomValues.Count > 1 ? " and " : "") + GetCmdsHelper.StorageTypeCustomValues[GetCmdsHelper.StorageTypeCustomValues.Count - 1];
            _logger.LogError("Missing/Invalid --type option.");
            _logger.LogError($"Valid options : {storageTypeDisplayList}");
            return false;
        }

        if (string.IsNullOrEmpty(commandSettings.AppHostProject))
        {
            _logger.LogError("Missing/Invalid --apphost-project option.");
            return false;
        }

        if (string.IsNullOrEmpty(commandSettings.Project))
        {
            _logger.LogError("Missing/Invalid --project option.");
            return false;
        }

        return true;
    }

    internal async Task InstallPackagesAsync(CommandSettings commandSettings)
    {
        List<AddPackagesStep> packageSteps = [];
        var appHostPackageStep= new AddPackagesStep
        {
            PackageNames = [PackageConstants.StoragePackages.AppHostStoragePackageName],
            ProjectPath = commandSettings.AppHostProject,
            Prerelease = commandSettings.Prerelease,
            Logger = _logger
        };

        if (PackageConstants.StoragePackages.StoragePackagesDict.TryGetValue(commandSettings.Type, out string? projectPackageName))
        {
            var workerProjPackageStep = new AddPackagesStep
            {
                PackageNames = [projectPackageName],
                ProjectPath = commandSettings.AppHostProject,
                Prerelease = commandSettings.Prerelease,
                Logger = _logger
            };

            packageSteps.Add(workerProjPackageStep);
        }

        foreach (var packageStep in packageSteps)
        {
            await packageStep.ExecuteAsync();
        }
    }
}
