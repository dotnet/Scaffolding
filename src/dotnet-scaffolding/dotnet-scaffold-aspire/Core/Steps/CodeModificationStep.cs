// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.DotNet.Scaffolding.Helpers.Roslyn;
using Microsoft.DotNet.Scaffolding.Helpers.Services.Environment;
using Microsoft.DotNet.Scaffolding.Helpers.Services;
using Microsoft.DotNet.Scaffolding.Helpers.Extensions.Roslyn;

namespace Microsoft.DotNet.Scaffolding.Steps;

internal class CodeModificationStep(string appHostProject, string targetProject, string configFileName, ILogger logger, IEnvironmentService environmentService, bool modifyConfig) : ScaffoldStep
{
    private readonly string _appHostProject = appHostProject;
    private readonly string _targetProject = targetProject;
    private readonly string _configFileName = configFileName;
    private readonly ILogger _logger = logger;
    private readonly IEnvironmentService _environmentService = environmentService;

    public async override Task<bool> ExecuteAsync()
    {
        if (!MSBuildLocator.IsRegistered)
        {
            MSBuildLocator.RegisterDefaults();
        }

        CodeModifierConfig? config = ProjectModifierHelper.GetCodeModifierConfig(_configFileName, System.Reflection.Assembly.GetExecutingAssembly());
        var workspaceSettings = new WorkspaceSettings
        {
            InputPath = _appHostProject
        };

        var hostAppSettings = new AppSettings();
        hostAppSettings.AddSettings("workspace", workspaceSettings);
        var codeService = new CodeService(hostAppSettings, _logger);

        CodeChangeOptions options = new()
        {
            IsMinimalApp = await ProjectModifierHelper.IsMinimalApp(codeService),
            UsingTopLevelsStatements = await ProjectModifierHelper.IsUsingTopLevelStatements(codeService)
        };

        if (modifyConfig)
        {
            var autoGeneratedProjectNames = await GetAutoGeneratedProjectNamesAsync(codeService);

            //edit CodeModifierConfig to add the web project name from _autoGeneratedProjectNames.
            autoGeneratedProjectNames.TryGetValue(_targetProject, out var autoGenProjectName);

            config = EditConfigForCaching(config, options, autoGenProjectName);
        }

        var projectModifier = new ProjectModifier(
            _environmentService,
            hostAppSettings,
            codeService,
            _logger,
            options,
            config);
        return await projectModifier.RunAsync();
    }

    private static async Task<Dictionary<string, string>> GetAutoGeneratedProjectNamesAsync(CodeService codeService)
    {
        var allDocuments = await codeService.GetAllDocumentsAsync();
        var allSyntaxRoots = await Task.WhenAll(allDocuments.Select(doc => doc.GetSyntaxRootAsync()));

        // Get all classes with the "Projects" namespace
        var classesInNamespace = allSyntaxRoots
            .SelectMany(root => root?.DescendantNodes().OfType<ClassDeclarationSyntax>() ?? [])
            .Where(cls => cls.IsInNamespace("Projects"))
            .ToList();

        Dictionary<string, string> autoGeneratedProjectNames = [];
        foreach (var classSyntax in classesInNamespace)
        {
            string? projectPathValue = classSyntax.GetStringPropertyValue("ProjectPath");
            // Get the full class name including the namespace
            var className = classSyntax.Identifier.Text;
            if (!string.IsNullOrEmpty(projectPathValue))
            {
                autoGeneratedProjectNames.Add(projectPathValue, $"Projects.{className}");
            }
        }

        return autoGeneratedProjectNames;
    }

    // Currently only formatting the 'builder.AddProject<{0}>' Parent value in one of the CodeChange's in redis-apphost.json' 
    internal static CodeModifierConfig? EditConfigForCaching(CodeModifierConfig? configToEdit, CodeChangeOptions codeChangeOptions, string? projectName)
    {
        if (configToEdit is null || string.IsNullOrEmpty(projectName))
        {
            return null;
        }

        var programCsFile = configToEdit.Files?.FirstOrDefault(x => !string.IsNullOrEmpty(x.FileName) && x.FileName.Equals("Program.cs", StringComparison.OrdinalIgnoreCase));
        if (programCsFile != null && programCsFile.Methods != null && programCsFile.Methods.Count != 0)
        {

            var addMethodMapping = programCsFile.Methods.Where(x => x.Key.Equals("Global", StringComparison.OrdinalIgnoreCase)).First().Value;
            var addProjectChange = addMethodMapping?.CodeChanges?.FirstOrDefault(x => !string.IsNullOrEmpty(x.Parent) && x.Parent.Contains("builder.AddProject<{0}>"));
            if (!codeChangeOptions.UsingTopLevelsStatements && addProjectChange != null)
            {
                addProjectChange = DocumentBuilder.AddLeadingTriviaSpaces(addProjectChange, spaces: 12);
            }

            if (addProjectChange != null && !string.IsNullOrEmpty(addProjectChange.Parent))
            {
                //update the parent value with the project name inserted.
                addProjectChange.Parent = string.Format(addProjectChange.Parent, projectName);
            }
        }

        return configToEdit;
    }
}
